.data    space:      .asciiz " "    newline:    .asciiz "\n"    dot:        .asciiz "."    zero_str:   .asciiz "0"    neg_sign:   .asciiz "-"        # 3 DÍGITOS DE PRECISÃO (1000.0)    const1000:  .float 1000.0    const0_5:   .float 0.5    const0:     .float 0.0.text.globl mainmain:    # 1. Ler Início (float)    li $v0, 6    syscall    mov.s $f20, $f0        # 2. Ler Fim (float)    li $v0, 6    syscall    mov.s $f22, $f0        # 3. Ler N (inteiro)    li $v0, 5    syscall    move $s0, $v0        # Imprimir o primeiro número    mov.s $f12, $f20    jal print_formatted        li $v0, 4    la $a0, space    syscall    # Prepara constantes do loop    # Denominador = N + 1    addi $t0, $s0, 1    mtc1 $t0, $f24    cvt.s.w $f24, $f24        li $t1, 1 # Contador kloop_interp:    bgt $t1, $s0, end_loop        # x = k    mtc1 $t1, $f26    cvt.s.w $f26, $f26        # y = (N + 1) - k    sub $t2, $t0, $t1    mtc1 $t2, $f28    cvt.s.w $f28, $f28        # Fórmula: p = (i*y + j*x) / (x+y)    mul.s $f4, $f20, $f28   # i * y    mul.s $f6, $f22, $f26   # j * x    add.s $f4, $f4, $f6     # Soma    div.s $f12, $f4, $f24   # Divisão        # Imprimir interpolado    jal print_formatted        li $v0, 4    la $a0, space    syscall        addi $t1, $t1, 1    j loop_interpend_loop:    # Imprimir o último número    mov.s $f12, $f22    jal print_formatted        li $v0, 4    la $a0, newline    syscall    li $v0, 10    syscall# -----------------------------------------------------------# Função de impressão formatada (3 casas decimais obrigatórias)# -----------------------------------------------------------print_formatted:    addi $sp, $sp, -4    sw $ra, 0($sp)        # Verificar sinal    lwc1 $f8, const0    c.lt.s $f12, $f8    bc1f positive_calc        li $v0, 4    la $a0, neg_sign    syscall    abs.s $f12, $f12    positive_calc:    lwc1 $f6, const1000    lwc1 $f8, const0_5        # Lógica: (int)trunc(numero * 1000 + 0.5)    mul.s $f12, $f12, $f6    add.s $f12, $f12, $f8        # IMPORTANTE: trunc.w.s remove a parte decimal sem arredondar    # O arredondamento já foi feito somando 0.5 antes    trunc.w.s $f12, $f12    mfc1 $t5, $f12        li $t6, 1000    div $t5, $t6    mflo $a0    # Parte inteira    mfhi $t7    # Parte fracionária (resto)        # Imprime Inteiro    li $v0, 1    syscall        li $v0, 4    la $a0, dot    syscall        # Padding de zeros para 3 casas (0 -> 000, 50 -> 050)    li $t8, 10    bge $t7, $t8, check_hundred       #include <stdio.h>#include <stdlib.h>#include <string.h>// Definição da estrutura do nó da árvoretypedef struct Node {    char data;    struct Node *left;    struct Node *right;} Node;// Função para criar um novo nóNode* createNode(char data) {    Node* newNode = (Node*)malloc(sizeof(Node));    newNode->data = data;    newNode->left = NULL;    newNode->right = NULL;    return newNode;}// Função para inserir um elemento na árvoreNode* insert(Node* root, char data) {    if (root == NULL) {        return createNode(data);    }    if (data < root->data) {        root->left = insert(root->left, data);    } else if (data > root->data) {        root->right = insert(root->right, data);    }    return root;}// Função de pesquisaint search(Node* root, char data) {    if (root == NULL) {        return 0; // Não encontrado    }    if (root->data == data) {        return 1; // Encontrado    }    if (data < root->data) {        return search(root->left, data);    } else {        return search(root->right, data);    }}// Percurso Infixo (Esquerda, Raiz, Direita)void infix(Node* root, int* first) {    if (root == NULL) return;    infix(root->left, first);        if (!*first) printf(" ");    printf("%c", root->data);    *first = 0;        infix(root->right, first);}// Percurso Prefixo (Raiz, Esquerda, Direita)void prefix(Node* root, int* first) {    if (root == NULL) return;        if (!*first) printf(" ");    printf("%c", root->data);    *first = 0;        prefix(root->left, first);    prefix(root->right, first);}// Percurso Posfixo (Esquerda, Direita, Raiz)void postfix(Node* root, int* first) {    if (root == NULL) return;    postfix(root->left, first);    postfix(root->right, first);        if (!*first) printf(" ");    printf("%c", root->data);    *first = 0;}// Função para liberar a memória da árvore (opcional para maratona, mas boa prática)void freeTree(Node* root) {    if (root == NULL) return;    freeTree(root->left);    freeTree(root->right);    free(root);}int main() {    Node* root = NULL;    char command[10];    char element;    // Lê os comandos até o fim do arquivo (EOF)    while (scanf("%s", command) != EOF) {        if (strcmp(command, "I") == 0) {            scanf(" %c", &element);            root = insert(root, element);        } else if (strcmp(command, "INFIXA") == 0) {            int first = 1;            infix(root, &first);            printf("\n");        } else if (strcmp(command, "PREFIXA") == 0) {            int first = 1;            prefix(root, &first);            printf("\n");        } else if (strcmp(command, "POSFIXA") == 0) {            int first = 1;            postfix(root, &first);            printf("\n");        } else if (strcmp(command, "P") == 0) {            scanf(" %c", &element);            if (search(root, element)) {                printf("%c existe\n", element);            } else {                printf("%c nao existe\n", element);            }        }    }    freeTree(root);    return 0;}